<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Knowledge Graph Embedding by Relational Rotation in Complex Space</title>
    <link href="/2023/11/20/RotatE/"/>
    <url>/2023/11/20/RotatE/</url>
    
    <content type="html"><![CDATA[<h1 id="RotatE-Knowledge-Graph-Embedding-by-Relational-Rotation-in-Complex-Space"><a href="#RotatE-Knowledge-Graph-Embedding-by-Relational-Rotation-in-Complex-Space" class="headerlink" title="RotatE: Knowledge Graph Embedding by Relational Rotation in Complex Space"></a>RotatE: Knowledge Graph Embedding by Relational Rotation in Complex Space</h1><p><u>负采样看不懂</u></p></br><p><strong>参考博客</strong></p><p>知乎：<a href="https://zhuanlan.zhihu.com/p/387378387">小白必看：一文读懂推荐系统负采样</a></p><p>博客：<a href="https://zhang-each.github.io/2021/08/08/reading9/">论文阅读笔记 9：GAN&amp;KBGAN</a></p><p>源码：<a href="https://github.com/DeepGraphLearning/KnowledgeGraphEmbedding">https://github.com/DeepGraphLearning/KnowledgeGraphEmbedding</a></p></br><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>我们研究<strong>实体和关系的低维向量表示</strong>的目的就是为了实现好的<strong>链路预测</strong>。</p><p>本文提出了一种新的知识图片嵌入方法 RotatE，该方法能够建模和推断各种关系模式（relation patterns），包括对称和反对称关系、反转关系、合成关系。</p><p>RotatE 将关系定义为，能够让源实体到目的实体的一个旋转。</p><p>此外，我们提出了一种新的<strong>自对抗负采样技术</strong>来有效地训练 RotatE 模型。</p><p>之前产生负例的方法是，替换正例中的实体。</p></br><h3 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h3><p>尽管“国家-城市”、“国家-大学”、“洲-国家”都属于“位置包含”关系，但是每个模式都涉及到<strong>不同类型的头尾实体对</strong>，反映了在知识图谱中的多样性。因此，在处理这样的关系时，需要考虑到不同的模式，而不仅仅是一个通用的关系向量。这样可以更准确地捕捉到不同实体对之间的语义关系。</p><blockquote><p>这是 TransR 中的举例。</p></blockquote></br><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote><p>随便看看</p></blockquote><p>知识图谱的应用：</p><ul><li>问答（question-answering）</li><li>信息检索（information retrieval）</li><li>推荐系统（recommender systems）</li><li>自然语言处理（natural language processing）</li></ul><p>关系模式：</p><ul><li>对称&#x2F;反对称关系（symmetry&#x2F;antisymmetry），如：婚姻&#x2F;父子关系</li><li>逆关系（inversion），如：上位词和下位词</li><li>复合关系（composition），如：我的母亲的丈夫是我的父亲</li></ul></br><h3 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h3><p><strong>欧拉公式</strong></p><p>欧拉公式首次将三角函数与复指数函数关联起来，因其提出者莱昂哈德·欧拉而得名，公式如下：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/euler.png" alt="欧拉公式"></p><p><strong>复平面</strong></p><p>下图是一个复平面，Im（Imaginary Axis）表示虚轴，Re（Real Axis）表示实轴。复平面中的二维单位向量 r_i，即 (cos(θ), sin(θ))，可以被写作复数形式 cos(θ)+isin(θ)，也可以再进一步通过欧拉公式被写作复指数形式。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/euler2.png" alt="复平面"></p><p><strong>几何含义</strong></p><p>当一个复数向量 (x, y) 乘以一个复数单位向量时，这个操作的几何含义是将该向量绕原点逆时针旋转（counterclockwise rotation）角度 θ 。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/euler3.png" alt="绕原点旋转"></p><p>为了更加直观地理解复数向量乘积的几何含义，我们接下来使用极坐标进行讨论。向量坐标如下：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/euler4.png" alt="极坐标"></p><p>计算 h_i 和 r_i 的乘积结果，发现等于 h_i’：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/euler5.png"></p><p>从而验证了复数向量 h_i 乘以复数单位向量 r_i 的几何含义是复数向量 h_i 绕原点逆时针旋转角度 θ 。</p><p>如果使用的是直角坐标系，则乘积结果为：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/euler6.png" alt="直角坐标系"></p></br><h3 id="RotatE"><a href="#RotatE" class="headerlink" title="RotatE"></a>RotatE</h3><p>基于欧拉公式，RotatE 把关系 relation 定义为使 h 能够到达 t 的一个旋转。具体来说，t 是 h 和 r 的元素乘积（Hadamard product），定义如下：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/RotatE.png" alt="RotatE对于r的定义"></p></br><h4 id="Hadamard-product"><a href="#Hadamard-product" class="headerlink" title="Hadamard product"></a>Hadamard product</h4><p>Hadamard product，也称为元素乘积，是指两个相同维度的矩阵（或向量）对应位置上的元素相乘得到的新矩阵（或向量）。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/HP.png" alt="Hadamard product"></p></br><h4 id="从关系模式的角度理解"><a href="#从关系模式的角度理解" class="headerlink" title="从关系模式的角度理解"></a>从关系模式的角度理解</h4><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/RotatE2.png" alt="从关系模式的角度理解"></p><ul><li>对称关系：r 的每个 r_i 都等于 1 或 -1，即 r_i 的角度为 π 的整数倍</li><li>逆关系：r_1 和 r_2 共轭，即实数部分相同而虚数部分互为相反数</li><li>复合关系：r_3 可以由 r_1 通过 r_2 旋转而来</li></ul></br><h2 id="Our-Method"><a href="#Our-Method" class="headerlink" title="Our Method"></a>Our Method</h2><h3 id="三种关系模式"><a href="#三种关系模式" class="headerlink" title="三种关系模式"></a>三种关系模式</h3><p>文中对“对称&#x2F;反对称关系”、“逆关系”、“复合关系”的定义如下：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/RP.png" alt="关系模式的定义"></p><p>作者说，目前没有一种模型可以同时很好地表示上述三种关系模式。</p></br><h3 id="RotatE-1"><a href="#RotatE-1" class="headerlink" title="RotatE"></a>RotatE</h3><p>受到欧拉公式的启发，作者把关系 relation 定义为：一种能让头实体 h 到达尾实体 t 的旋转，而且是一种 element-wise 的旋转，即向量中的各个元素是分别旋转的（t_i&#x3D;h_i*r_i）。具体定义如下：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/RotatE3.png" alt="r是一种旋转"></p><p>其中的 C 代表“Complex”，即 h、t、r 被映射到复数平面，而不是实数平面。约束 r_i 的模长为 1，使得 r_i 是一个单位向量。实体向量与 r_i 相乘，只会被影响到相位（phase），而不会被影响到幅度（magnitude）。</p><blockquote><p>相位表示向量的旋转角度，幅度表示向量的长度。</p></blockquote><p>从而 RotatE 的 distance function 为：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/RotatE5.png" alt="distance function"></p><blockquote><p>Trans 系列都叫的是 score function。</p></blockquote></br><h4 id="使用的范数"><a href="#使用的范数" class="headerlink" title="使用的范数"></a>使用的范数</h4><p>本文使用的都是 L1-norm：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/Lp3.png" alt="Lp-norm"></p></br><h4 id="与-TransE-的比较"><a href="#与-TransE-的比较" class="headerlink" title="与 TransE 的比较"></a>与 TransE 的比较</h4><p>RotatE 能区分“对称”关系，而 TransE 不能区分“对称”关系。所谓能够区分关系模式，就是指能够区分实体的不同。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/RotatE4.png" alt="TransE和RotatE&lt;/br&gt;translation是平移，rotation是旋转"></p><p>“The reason is that in TransE, <strong>any symmetric relation will be represented by a 0 translation vector</strong>. As a result, this will push the entities with symmetric relations to be close to each other in the embedding space.”</p><p>因此，TransE 会把“对称”关系中的头实体和尾实体误认为是同一个实体。而 RotatE 不会遇到这种问题，头实体要通过关系旋转 180°才能到达尾实体，因此它俩的向量表示不同，从而能够被区分。此外，不同的“对称”关系也能由不同的向量来表示，而不是被笼统地归纳为 0 向量。</p></br><h3 id="自对抗负采样"><a href="#自对抗负采样" class="headerlink" title="自对抗负采样"></a>自对抗负采样</h3><blockquote><p>负采样算法的本质就是基于某些方式来设置或调整负采样时的采样分布。</p></blockquote><p>本文采用的损失函数：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/NS.png" alt="loss function"></p><p>传统的负采样方法就是随机替换三元组中的 h 或者 t 来得到一个负样本，但这种方式产生的负样本可能太平凡了，很容易被模型判断出来是错的。我们训练模型就是想让它学会如何辨别一个三元组是不是合理的，而如果三元组太容易被辨别出来，训练就没有效果了。</p><p>因此，作者提出的自对抗负采样：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/NS2.png" alt="self-adversarial negative sampling"></p>]]></content>
    
    
    
    <tags>
      
      <tag>知识图谱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learning Entity and Relation Embeddings for Knowledge Graph Completion</title>
    <link href="/2023/11/19/TransR/"/>
    <url>/2023/11/19/TransR/</url>
    
    <content type="html"><![CDATA[<h1 id="Learning-Entity-and-Relation-Embeddings-for-Knowledge-Graph-Completion"><a href="#Learning-Entity-and-Relation-Embeddings-for-Knowledge-Graph-Completion" class="headerlink" title="Learning Entity and Relation Embeddings for Knowledge Graph Completion"></a>Learning Entity and Relation Embeddings for Knowledge Graph Completion</h1><p><strong>参考博客</strong></p><p>知乎：<a href="https://yaoleo.github.io/2017/10/27/TransE%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/">TransE 算法的理解</a></p><p>知乎：<a href="https://zhuanlan.zhihu.com/p/359925162">TransE、TransH、TransR 和 TransD</a></p><p>知乎：<a href="https://zhuanlan.zhihu.com/p/144412694">知识表示学习 Trans 系列梳理（论文+代码）</a></p></br><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>知识图谱补全&#x3D;在现有知识图的监督下进行两个实体之间的链路预测</p><p>本文考虑从 knowledge graph embeddings 入手以解决问题。</p><p>前人提出的 TransE 和 TransH 等模型，是通过将关系视为从头部实体到尾部实体的转换，来将三元组（实体、属性、关系）翻译成 embedding 词向量，即一个<strong>低维的向量</strong>。</p><p>我们注意到这些模型还是把实体和关系放在同一个语义空间中的。</p><p>事实上，一个实体有多个方面，它的每个关系可能聚焦在不同的方面，这使得采用相同的语义空间不足以建模。直观的是，一些实体是相似的，因此在实体空间中彼此接近，但在某些特定方面却大不相同，因此在相应的关系空间中彼此相距很远。</p><p>在本文中，我们提出了 TransR 在单独的实体空间和关系空间中构建实体和关系嵌入。</p><p>之后，我们先将实体从实体空间投影到相应的关系空间来学习嵌入，然后在投影的实体之间建立关系。</p><p>在实验中，我们在三个任务上评估我们的模型，包括链接预测、三重分类和关系事实提取。</p><p>源码：<a href="https://github.com/mrlyk423/relation_extraction">https://github.com/mrlyk423/relation_extraction</a></p></br><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote><p>由于对链路预测不熟，所以看了 introduction。</p></blockquote><p>三元组 (h, r, t)，符号含义：</p><ul><li>h：head entity</li><li>r：relation</li><li>t：tail entity</li></ul><p>实体空间中的 h 和 t 被投影到关系空间后，被表示为 h_r 和 t_r，三者之间的关系是 h_r + r ≈ t_r。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/TransR1.png" alt="TransR的基本思想"></p><p>这种 relation-specific 的投影可以使之间存在关系的头部实体 h_r 和尾部实体 t_r （圆形）彼此接近，同时还能远离与它们没有关系的实体（三角形）。</p><p>在 head-tail 实体对中，实体之间关系的模式非常多样。例如，“location-location-contains”就可以是“country-city”、“country-university”或者“continent-country”。我们通过将不同的 head-tail 实体对聚类成组，并为每个组学习不同的关系向量来扩展 TransR，称为基于聚类的 TransR（CTransR）。</p></br><h2 id="Related-Models"><a href="#Related-Models" class="headerlink" title="Related Models"></a>Related Models</h2><h3 id="TransE"><a href="#TransE" class="headerlink" title="TransE"></a>TransE</h3><p>TransE 认为一个正确的三元组的 embedding 向量 (h, r, t) 会满足公式：h+r&#x3D;t，即头实体的 embedding 加上关系的 embedding 会等于尾实体的 embedding。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/TransE2.jpg" alt="TransE的基本思想"></p><p>如果是一个错误的三元组，那么三者的 embedding 就不会满足这种关系。</p><p>根据上述观点，TransE 的 score function 如下图所示：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/TransE.png" alt="TransE的score function及其缺点"></p><p>虽然 TransE 具有训练速度快、易于实现等优点，但是<strong>它不能够处理 N-to-1、1-to-N 和 N-to-N 的关系</strong>。以 N-to-1 关系为例，三元组 (h_i, r, t) 中的 r 和 t 固定，TransE 为了满足三角闭包关系，训练出来的 h_i 向量会很相似。</p><p>同理，处理 1-to-N 关系时也会存在此类问题。例如，知识库中有两个三元组，分别是 (美国, 总统, 特朗普) 和 (美国, 总统, 拜登)，这里的“总统”关系是典型的 1-to-N 关系。如果用 TransE 从这两个三元组学习知识表示，则会使“特朗普”和“拜登”的向量变得相同，这显然不符合事实。</p></br><h4 id="L2-范数"><a href="#L2-范数" class="headerlink" title="L2 范数"></a>L2 范数</h4><p>L2 范数，又称为欧几里得范数，可以防止过拟合，提升模型的泛化能力。</p><p>其计算步骤如下：</p><ol><li>对向量的每个维度进行平方操作</li><li>将所有平方值相加</li><li>对结果取平方根</li></ol><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/L2.png" alt="L2的计算公式"></p></br><h4 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h4><p>范数（Norm）是一个对向量空间中的向量进行度量或测量的概念，可以理解为<strong>向量的大小或长度</strong>。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/Lp.png" alt="范数的定义"></p><p>其中 p 是一个正整数或是无穷大。常见的范数包括：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/Lp2.png" alt="常见的范数"></p><blockquote><p>此外，L0 范数是指向量中非 0 的元素的个数。</p><p>来自知乎：<a href="https://zhuanlan.zhihu.com/p/28023308">https://zhuanlan.zhihu.com/p/28023308</a></p></blockquote></br><h3 id="TransH"><a href="#TransH" class="headerlink" title="TransH"></a>TransH</h3><p><strong>英文全称：</strong>translating on hyperplanes（超平面）</p><p><strong>核心思想：</strong>对于每一个关系 relation，都由一个超平面上的关系向量 r 和该超平面的法向量（the normal vector）W_r 表示，而不是和实体、关系在同一个嵌入空间。</p><p>具体来说，对于每个三元组 (h, r, t)，将头实体 h 和尾实体 t 都映射到超平面 W_r 上，得到向量 h⊥ 和 t⊥，训练使 h⊥+r≈t⊥。目的是通过不同的关系拥有的不同的法平面，让同一个实体 h 或 t 在不同关系中拥有不同的意义。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/TransH2.png" alt="TransH和TransE的对比"></p><p>回到我们上面的 N-to-1 的复杂关系问题。对于三元组 (h_1, r, t) 和 (h_2, r, t)，根据 TransE 的思想，则有 h_1&#x3D;h_2；而根据 TransH 的思想，只需满足 h_1 和 h_2 在关系 r 的超平面 W_r 上的投影相同即可。这样就可以区分出 h_1 和 h_2，因为两个向量的向量表示是不同的。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/TransH.png" alt="TransH的score function"></p></br><h4 id="向量投影"><a href="#向量投影" class="headerlink" title="向量投影"></a>向量投影</h4><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/proj.png" alt="向量投影公式"></p><blockquote><p>TransH 限制了 W_r 的模长为 1，所以公式长那样。</p></blockquote></br><h4 id="超平面"><a href="#超平面" class="headerlink" title="超平面"></a>超平面</h4><p>超平面（hyperplane）是一个比所嵌套的空间低一维的线性子空间。具体来说，在二维空间中，超平面是一条直线；在三维空间中，它是一个平面；在更高维度的空间中，它是一个超曲面。</p></br><h2 id="Our-Method"><a href="#Our-Method" class="headerlink" title="Our Method"></a>Our Method</h2><h3 id="TransR"><a href="#TransR" class="headerlink" title="TransR"></a>TransR</h3><p>TransR 在不同的语义空间表示实体和关系，并用 relation-specific 的矩阵将两个空间连接起来。效果提升不大，但计算量显著增大。</p><p>创新点是将 TransH 的“投影到超平面”更进一步“投影到空间”，本质是将投影向量换为投影矩阵。实体还是用一个向量表示，关系用一个向量 r 和一个矩阵 M_r 表示。变量定义如下：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/TransR2.png" alt="变量定义"></p><p>实体空间（h 和 t）的维度和关系空间（r）的维度不同，由矩阵 M_r 完成从实体空间到关系空间的投影。TransR 的 score function 如下：</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/TransR3.png" alt="score function"></p><p>score function 的模式和 TransE、TransH 的相同，此外还增加了一些约束。</p></br><h3 id="Cluster-based-TransR-CTransR"><a href="#Cluster-based-TransR-CTransR" class="headerlink" title="Cluster-based TransR (CTransR)"></a>Cluster-based TransR (CTransR)</h3><p>不管是 TransE、TransH 还是 TransR，为每个 relation 都只学习了一个矩阵 M，这意味着它们不能拟合到该关系下的所有实体对，因为关系的模式相当多样。</p><p>基本思想：</p><p>首先将输入实例分成几个组。对于特定的关系 r，将它对应的所有实体对 (h, t) 聚类成多个组。对于每个组里的实体对，它们都应该表现出相同的 r 关系。所有实体对 (h, t) 都用它们的向量偏移量 (h − t) 来进行聚类，其中 h 和 t 是使用 TransE 获得。然后，我们分别为每个聚类学习关系向量 r_c，为每个关系学习矩阵 M_r。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/CTransR.png" alt="CTransR的score function"></p><p>r_c-r 保证 cluster-specific 的关系向量 r_c 不要离原始的关系向量 r 太远，CTransR 也对 h、r、t 和 M 的范数有约束。</p></br><h3 id="Training-Method-and-Implementation-Details"><a href="#Training-Method-and-Implementation-Details" class="headerlink" title="Training Method and Implementation Details"></a>Training Method and Implementation Details</h3><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/loss.png" alt="损失函数"></p><p>S 是正确的三元组（正例）的集合，S’ 是错误的三元组（负例）的集合。</p><p><strong>负例的产生</strong></p><p>通常我们得到的知识库是三元组的集合，所有在知识库中出现了的三元组都会被看作是正例。我们通常使用替换法来获取负例，即用其它实体替换掉正例中的实体。对于三元组 (h, r, t)，我们会随机抽取知识库中的某个实体 h’ 来替换 h，或者用某个实体 t’ 来替换 t，这样我们就得到了两个负例 (h’, r, t) 和 (h, r, t’)。</p><p>对于那些 1-to-N、N-to-1 和 N-to-N 关系，通过提供更多替换“one”边的机会，可以减少生成 false-negative（假阴性）实例的机会。</p><p><strong>反向传播和初始化</strong></p><p>反向传播用的是随机梯度下降法（stochastic gradient descent, SGD）；为了避免过拟合，使用 TransE 的结果来初始化实体和关系的向量，使用单位矩阵来初始化关系矩阵。</p>]]></content>
    
    
    
    <tags>
      
      <tag>知识图谱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识图谱构建流程详解</title>
    <link href="/2023/11/17/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <url>/2023/11/17/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>参考博客</strong></p><p>知乎：<a href="https://zhuanlan.zhihu.com/p/145447330">https://zhuanlan.zhihu.com/p/145447330</a></p><p>博客园：<a href="https://www.cnblogs.com/huangyc/p/10043749.html">https://www.cnblogs.com/huangyc/p/10043749.html</a></p><p>综述：<a href="http://kns-cnki-net-s.vpn.uestc.edu.cn:8118/KXReader/Detail?invoice=TfXLC2ZSNT9XLq1SP5F5Q9DYo1dpuUSVTM87GLoVDLiokXx5M8xMFoGMu7aMK/3Ct/fki/LdQgDhVvrV505vCEn2VAA3pa6x0jPIWd5WW/alFPDMCs3HfKHXXce3tMJ5b1t90Tg+SvdD9M68sD10nMMgtW8puh+wjUu1P858iwA=&DBCODE=CJFQ&FileName=JFYZ201603009&TABLEName=cjfdlast2016&nonce=49E73AC3869B4489BBF4BDE9628A1CDA&TIMESTAMP=1700221256698&uid=">知识图谱构建技术综述</a></p><p>清华 XLore：<a href="https://xlore.cn/index">https://xlore.cn/index</a></p></br><h2 id="一、知识图谱简介"><a href="#一、知识图谱简介" class="headerlink" title="一、知识图谱简介"></a>一、知识图谱简介</h2><h3 id="1-1-历史沿革"><a href="#1-1-历史沿革" class="headerlink" title="1.1  历史沿革"></a>1.1  历史沿革</h3><p>提出知识图谱的目的：</p><ul><li>实现智能化语义检索</li><li>解决信息检索问题</li></ul><p>虽然知识图谱的概念较新，但它并非是一个全新的研究领域。早在 2006 年，Berners-Lee 就提出了数据链接（linkeddata）的思想，呼吁推广和完善相关的技术标准如：</p><ul><li>URI（uniform resource identifier）</li><li>RDF（resource description framework）</li><li>OWL（ontology language）</li></ul><p>为迎接<strong>语义网络</strong>时代的到来做好准备。随后掀起了一场语义网络研究热潮，知识图谱技术正是建立在相关的研究成果之上的，是对现有语义网络技术的一次扬弃和升华。</p></br><h3 id="1-2-定义"><a href="#1-2-定义" class="headerlink" title="1.2  定义"></a>1.2  定义</h3><p>定义：知识图谱是<strong>结构化的语义知识库</strong>，用于以符号形式描述物理世界中的概念及其相互关系。其基本组成单位是<strong>“实体-关系-实体”三元组，以及实体及其相关属性-值对</strong>。实体间通过关系相互联结，构成网状的知识结构。</p><p>通过知识图谱，可以实现 web 从网页链接（web1.0）向概念链接转变，<strong>支持用户按主题而不是字符串检索</strong>，从而真正实现语义检索。基于知识图谱的搜索引擎，能够<strong>以图形方式向用户反馈结构化的知识</strong>，用户不浏览大量网页，就可以准确定位和深度获取知识。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/graphpng.png" alt="诸葛亮-清华博拉图"></p><p>上述定义包含 3 层含义：</p><ul><li>知识图谱是由许多具有属性的实体通过关系链接而成的网状知识库。从图的角度来看，知识图谱在本质上是一种<strong>概念网络</strong>，其中的<strong>节点表示物理世界的实体（或概念）</strong>，而实体间的各种语义关系则构成网络中的边。由此，知识图谱是对物理世界的一种符号表达。</li><li>知识图谱的研究价值在于，它是构建在当前 web 基础之上的一层<strong>覆盖网络（overlay network）</strong>，借助知识图谱，能够在 web 网页之上建立概念间的链接关系，从而以最小的代价将互联网中积累的信息组织起来，成为可以被利用的知识<strong>（信息–&gt;知识）</strong></li><li>知识图谱的应用价值在于，它能够改变现有的信息检索方式，一方面<strong>通过推理实现概念检索</strong>（相对于现有的字符串模糊匹配方式而言）；另一方面以<strong>图形化方式</strong>向用户展示经过分类整理的结构化知识，从而使人们从人工过滤网页寻找答案的模式中解脱出来。</li></ul><p>知识图谱的分类：</p><ul><li>用于构建结构化的百科知识的“通用知识图谱”</li><li>基于行业数据构建和应用的“领域知识图谱”</li></ul></br><h3 id="1-3-架构"><a href="#1-3-架构" class="headerlink" title="1.3  架构"></a>1.3  架构</h3><p>知识图谱的架构包含：</p><ul><li>知识图谱自身的逻辑结构，分为数据层、模式层</li><li>构建知识图谱所采用的技术架构</li></ul><p><strong>知识图谱自身的逻辑结构</strong></p><p>在知识图谱的数据层，<strong>知识以事实（fact）为单位存储在图数据库</strong>。例如谷歌的 Graphd 和微软的 Trinity 都是典型的图数据库。如果<strong>以“实体-关系-实体”或者“实体-属性-属性值”三元组作为事实的基本表达方式</strong>，则存储在图数据库中的所有数据将构成庞大的实体关系网络，形成知识的“图谱”。</p><p>模式层位居数据层之上，是知识图谱的核心。在模式层存储的是经过提炼的知识，通常采用<strong>本体库</strong>来管理知识图谱的模式层，借助<strong>本体库对公理、规则和约束条件的支持能力</strong>来规范实体、关系以及实体的类型和属性等对象之间的联系。本体库在知识图谱中的地位相当于知识库的模具，拥有本体库的知识库冗余知识较少。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/human.png" alt="本体定义-人类"></p><p><strong>构建知识图谱所采用的技术架构</strong></p><p>下图给出了知识图谱技术的整体架构，其中虚线框内的部分为知识图谱的构建过程，同时也是知识图谱更新的过程。</p><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/process.jpg" alt="知识图谱构建过程"></p><p>如图所示，<strong>知识图谱的构建过程</strong>是从原始数据出发，采用一系列自动或半自动的技术手段，从原始数据中提取出知识要素（即事实），并将其存入知识库的数据层和模式层的过程。</p><p>这是一个迭代更新的过程，根据知识获取的逻辑，每一轮迭代包含 3 个阶段：</p><ol><li><strong>信息抽取：</strong>从各种类型的数据源中提取出实体、属性以及实体间的相互关系，在此基础上将知识以本体的形式进行表达（本体对实体、属性和关系制定了规则和约束）；</li><li><strong>知识融合：</strong>在获得新知识之后，还需要对其进行整合，以消除矛盾和歧义。比如某些实体可能有多种表达，某个特定称谓也许对应于多个不同的实体等；</li><li><strong>知识加工：</strong>对于经过融合的新知识，还需要接受质量评估（部分需要人工参与甄别），合格的部分才能被加入到知识库中，以确保知识库的质量。新增数据之后，可以进行<strong>知识推理</strong>，以拓展现有知识，得到新的知识。</li></ol><p>知识图谱有 2 种构建方式：</p><ul><li><strong>自顶向下构建：</strong>是指借助百科类网站等结构化数据源，从高质量数据中提取本体和模式信息，加入到知识库中。</li><li><strong>自底向上构建：</strong>是指借助一定的技术手段，从公开采集的数据中<strong>提取出资源模式</strong>，选择其中置信度较高的新模式，经人工审核之后，加入到知识库中。如：谷歌的 Knowledge Vault、微软的 Satori 等。</li></ul><blockquote><p>GPT：提取出资源模式就是指提取出数据中包含的实体、属性、关系。</p></blockquote></br><p><strong>Data Acquisition 中的数据类型</strong></p><p>知识图谱的<strong>原始数据</strong>类型一般来说有三类，也是互联网上的三类原始数据：</p><ul><li>结构化数据（Structed Data）：如关系数据库</li><li>半结构化数据（Semi-Structed Data）：如 XML、JSON、百科</li><li>非结构化数据（UnStructed Data）：如图片、音频、视频、文本</li></ul><p>原始数据存储方式：</p><ul><li>使用 RDF（资源描述框架）等规范存储格式来进行存储</li><li>使用 Neo4j 等常用的图数据库来进行存储</li></ul><blockquote><p>在知识图谱方面，图数据库比关系数据库灵活的多。在数据少的时候，关系数据库也没有问题，效率也不低。但是随着知识图谱变的复杂，图数据库的优势会明显增加。当涉及到 2、3 度的关联查询，基于图数据库的效率会比关系数据库的效率高出几千倍甚至几百万倍。</p></blockquote></br><hr><p>接下来介绍的是“知识图谱的构建技术”。</p><hr></br><h2 id="二、信息抽取"><a href="#二、信息抽取" class="headerlink" title="二、信息抽取"></a>二、信息抽取</h2><p>信息抽取（infromation extraction）是知识图谱构建的第1步，其中的关键问题是：如何从异构数据源中自动抽取信息得到候选知识单元？（候选知识单元：被认为可能包含有用知识的单元或片段。）</p><p>信息抽取是一种自动化地从半结构化、非结构化数据中抽取<strong>实体、关系以及实体属性等结构化信息</strong>的技术。</p><p>关键技术包括：实体抽取、关系抽取、属性抽取。</p></br><h3 id="2-1-实体抽取（Entity-Extraction）"><a href="#2-1-实体抽取（Entity-Extraction）" class="headerlink" title="2.1  实体抽取（Entity Extraction）"></a>2.1  实体抽取（Entity Extraction）</h3><p>实体抽取又称为命名实体识别（named entity recognition，NER），是指<strong>从文本数据集中自动识别出命名实体</strong>。</p><p>实体抽取的质量（准确率和召回率）对后续的知识获取效率和质量影响极大，因此是信息抽取中最为基础和关键的部分。</p><blockquote><p>召回率</p><p>$Recall&#x3D;\frac{True Positives+False Negatives}{True Positives} $</p><p>用于衡量模型能够正确识别正例样本的能力。</p></blockquote><p>早期对实体抽取方法的研究主要面向单一领域（如特定行业或特定业务），关注如何识别出文本中的人名、地名等专有名词和有意义的时间等实体信息。</p><table><thead><tr><th>方法</th><th>效果</th></tr></thead><tbody><tr><td>Raul；基于规则的方法</td><td>耗费大量的人力，且可扩展性较差，难以适应数据的变化</td></tr><tr><td>Liu；基于有监督学习；K-最近邻算法和条件随机场模型</td><td>在准确率和召回率上的表现都不够理想，且算法的性能依赖于训练样本的规模</td></tr><tr><td>Lin；基于有监督学习和规则；采用字典辅助下的最大熵算法</td><td>在基于 Meline 论文摘要的 GENIA 数据集上取得了实体抽取准确率和召回率均超过 70％ 的实验结果</td></tr></tbody></table><p>随着命名实体识别技术不断取得进展，学术界开始关注开放域（open domain）的信息抽取问题，即不再限定于特定的知识领域，而是面向开放的互联网，研究和解决全网信息抽取问题。</p><table><thead><tr><th>方法</th><th>效果</th></tr></thead><tbody><tr><td>Sekine；命名实体分类体系</td><td>将网络中的所有命名实体划分为 150 个分类</td></tr><tr><td>Ling；借鉴 Freebase 的实体分类方法</td><td>归纳出 112 个实体类别，并基于条件随机场模型进行实体边界识别，最后采用自适应感知机算法实现了对实体的自动分类，其实验结果显著优于 StanfordNER 等当前主流的命名实体识别系统</td></tr></tbody></table><p>然而，互联网中的内容是动态变化的，web2.0 技术更进一步推动了互联网的概念创新，采用人工预定义实体分类体系的方式已经很难适应时代的需求。</p><p>面向开放域的实体抽取和分类技术能够较好地解决这一问题，该方法的基本思想是对于任意给定的实体，采用统计机器学习的方法，从目标数据集（通常是网页等文本数据）中抽取出与之具有相似上下文特征的实体，从而实现实体的分类和聚类。在面向开放域的实体识别和分类研究中，不需要（也不可能）为每个领域或每个实体类别建立单独的语料库作为训练集。因此，该领域面临的主要挑战是如何从给定的少量实体实例中自动发现具有区分力的模式。</p><table><thead><tr><th>方法</th><th>效果</th></tr></thead><tbody><tr><td>Whitelaw；提出了一种迭代扩展实体语料库的解决方案</td><td>基本思路是根据已知的实体实例进行特征建模，利用该模型处理海量数据集得到新的命名实体列表，然后针对新实体建模，迭代地生成实体标注语料库</td></tr><tr><td>Jain；提出了一种面向开放域的无监督学习算法；通过搜索引擎的服务器日志获取新出现的命名实体</td><td>事先并不给出实体分类，而是基于实体的语义特征从搜索日志中识别出命名实体，然后采用聚类算法对识别出的实体对象进行聚类，该方法已经在搜索引擎技术中得到应用，用于根据用户输入的关键字自动补全信息</td></tr></tbody></table></br><h3 id="2-2-关系抽取（Relation-Extraction）"><a href="#2-2-关系抽取（Relation-Extraction）" class="headerlink" title="2.2  关系抽取（Relation Extraction）"></a>2.2  关系抽取（Relation Extraction）</h3><p>文本语料经过实体抽取，得到的是一系列离散的命名实体，为了得到语义信息，还需要<strong>从相关的语料中提取出实体之间的关联关系</strong>，通过关联关系将实体（概念）联系起来，才能够形成网状的知识结构。研究关系抽取技术的目的，就是解决如何从文本语料中抽取实体间的关系这一基本问题。</p><ol><li>人工构造语法和语义规则（模式匹配）</li><li>统计机器学习方法</li><li>基于特征向量或核函数的有监督学习方法</li><li>研究重点转向半监督和无监督</li><li>开始研究面向开放域的信息抽取方法</li><li>将面向开放域的信息抽取方法和面向封闭领域的传统方法结合</li></ol></br><h3 id="2-3-属性抽取（Attribute-Extraction）"><a href="#2-3-属性抽取（Attribute-Extraction）" class="headerlink" title="2.3  属性抽取（Attribute Extraction）"></a>2.3  属性抽取（Attribute Extraction）</h3><p>属性抽取的目标是从不同信息源中采集特定实体的属性信息。例如针对某个公众人物，可以从网络公开信息中得到其昵称、生日、国籍、教育背景等信息。属性抽取技术能够从多种数据来源中汇集这些信息，实现对实体属性的完整勾画。</p><p>由于可以将实体的属性视作实体与属性值之间的一种名词性关系，因此也可以<strong>将属性抽取任务转化为关系抽取任务</strong>。</p><ul><li>基于规则和启发式算法，抽取结构化数据。</li><li>基于百科类网站的半结构化数据，通过自动抽取生成训练语料，用于训练实体属性标注模型，然后将其应用于对非结构化数据的实体属性抽取。</li><li>采用数据挖掘的方法直接从文本中挖掘实体属性和属性值之间的关系模式，据此实现对属性名和属性值在文本中的定位。</li></ul><p>采用数据挖掘的方法的基本假设是属性名和属性值之间有位置上的关联关系，事实上在真实语言环境中，许多实体属性值附近都存在一些用于限制和界定该属性值含义的<strong>关键字（属性名）</strong>，在自然语言处理技术中将这类属性称为<strong>有名属性</strong>，因此<strong>可以利用这些关键字来定位有名属性的属性值</strong>。</p></br></br><h2 id="三、知识融合"><a href="#三、知识融合" class="headerlink" title="三、知识融合"></a>三、知识融合</h2><p>通过信息抽取，我们就从原始的半结构化、非结构化数据中获得了实体、关系以及实体的属性信息。</p><p>仍需解决的问题：</p><ul><li>信息之间的关系是扁平化的，缺乏层次性和逻辑性</li><li>知识中还存在大量冗杂和错误的信息</li></ul><p>知识融合包括两部分内容：实体链接、知识合并。</p></br><h3 id="3-1-实体链接（Entity-Linking）"><a href="#3-1-实体链接（Entity-Linking）" class="headerlink" title="3.1  实体链接（Entity Linking）"></a>3.1  实体链接（Entity Linking）</h3><p>实体链接是指将文本中抽取得到的实体对象链接到知识库中对应的实体对象。</p><p>基本思想：</p><ol><li>根据给定的<strong>实体指称项</strong>，从知识库中选出一组候选实体对象；</li><li>通过相似度计算将实体指称项链接到正确的实体对象。</li></ol><p>研究历史：</p><ol><li>仅关注如何将从文本中抽取到的实体链接到知识库中，忽视了位于同一文档的实体间存在的语义联系。</li><li>开始关注利用实体的共现关系，同时将多个实体链接到知识库中，即集成实体链接（collective entity linking）。</li></ol><p>实体链接的流程：</p><ul><li>从文本中通过实体抽取得到实体指称项。</li><li>进行<strong>实体消歧</strong>和<strong>共指消解</strong>：<ul><li>判断知识库中同名的实体是否与之表示不同的含义</li><li>判断知识库中不同名的实体是否与之表示相同的含义</li></ul></li><li>在确认知识库中对应的正确实体对象之后，将该实体指称项链接到知识库中对应实体。</li></ul><blockquote><p><strong>实体指称项</strong></p><p>在知识图谱中，实体指标项通常是指关联到特定实体的属性或特征，这些属性或特征可以用来描述该实体。实体指标项有助于更全面地了解和表达实体的性质、特征或其它相关信息。以下是一些可能包含在知识图谱中的实体指标项的示例：</p><ul><li><p>人物实体的指标项：</p><ul><li>姓名</li><li>出生日期</li><li>出生地</li><li>职业</li><li>教育背景</li><li>家庭关系</li></ul></li><li><p>地点实体的指标项：</p><ul><li>名称</li><li>地理坐标</li><li>人口</li><li>面积</li><li>历史事件</li><li>相关地理特征</li></ul></li></ul></blockquote></br><h4 id="3-1-1-实体消歧"><a href="#3-1-1-实体消歧" class="headerlink" title="3.1.1  实体消歧"></a>3.1.1  实体消歧</h4><p>实体消歧主要用于解决同名的实体之间存在歧义的问题。</p><p>例如，“李娜”这个名词（指称项）可以对应于作为歌手的李娜这个实体，也可以对应于作为网球运动员的李娜这个实体。</p><p>通过实体消歧，就可以根据当前的语境，准确建立实体链接，实体消歧主要采用聚类法。聚类法是指以实体对象为聚类中心，将所有指向同一目标实体对象的指称项聚集到以该对象为中心的类别下。采用聚类法消歧的关键问题是<strong>如何定义实体对象与指称项之间的相似度</strong>，常用方法有 4 种。</p></br><h4 id="3-1-2-共指消解"><a href="#3-1-2-共指消解" class="headerlink" title="3.1.2  共指消解"></a>3.1.2  共指消解</h4><p>共指消解主要用于解决多个实体指称项对应同一实体对象的问题。</p><p>例如，在一篇新闻稿中，“Barack Obama”、“president Obama”、“the president” 等指称项指向的是同一实体对象，其中的许多代词如 “he”、“him” 等，也可能指向该实体对象。</p><p>利用共指消解技术，可以<strong>将这些指称项关联（合并）到正确的实体对象</strong>，由于该问题在信息检索和自然语言处理等领域具有特殊的重要性，吸引了大量的研究努力。</p><p>共指消解还有一些其它的名字，比如：</p><ul><li>对象对齐（object alignment）</li><li>实体匹配（entity matching）</li><li>实体同义（entity synonyms）</li></ul></br><h3 id="3-2-知识合并"><a href="#3-2-知识合并" class="headerlink" title="3.2  知识合并"></a>3.2  知识合并</h3><p>在构建知识图谱时，可以从第三方知识库产品或已有的结构化数据获取知识输入。</p><p>常见的知识合并需求有两个：</p><ul><li>合并外部知识库</li><li>合并关系数据库</li></ul><p>合并外部知识库：</p><ul><li>数据层的融合，包括实体的指称、属性、关系以及所属类别等，主要的问题是如何避免实例以及关系的冲突问题，造成不必要的冗余</li><li>模式层的融合，将新得到的本体融入已有的本体库中</li></ul><p>合并关系数据库：在知识图谱构建过程中，一个重要的高质量知识来源是企业或者机构自己的关系数据库。为了将这些结构化的历史数据融入到知识图谱中，可以采用资源描述框架（RDF）作为数据模型。业界和学术界将这一数据转换过程形象地称为 RDB2RDF，其实质就是将关系数据库的数据换成 RDF 的三元组数据。</p></br></br><h2 id="四、知识加工"><a href="#四、知识加工" class="headerlink" title="四、知识加工"></a>四、知识加工</h2><p>在前面，我们已经通过信息抽取，从原始语料中提取出了实体、关系与属性等知识要素，并且经过知识融合，消除实体指称项与实体对象之间的歧义，得到一系列基本的事实表达。</p><p>然而事实本身并不等于知识。要想最终获得结构化，网络化的知识体系，还需要经历知识加工的过程。</p><p>知识加工主要包括 3 方面内容：本体构建、知识推理、质量评估。</p></br><h3 id="4-1-本体构建"><a href="#4-1-本体构建" class="headerlink" title="4.1  本体构建"></a>4.1  本体构建</h3><p>本体（ontology）是指人工的概念集合、概念框架，是描述客观世界的抽象模型，如“人”、“事”、“物”等。在知识图谱中，本体位于模式层，用于描述概念层次体系，是知识库中知识的概念模板。</p><p>本体的最大特点在于它是<strong>共享的</strong>：</p><ul><li>本体中反映的知识是一种明确定义的共识</li><li>本体是同一领域内不同主体间交流的语义基础</li></ul><p>本体是树状结构，相邻层次的节点（概念）之间具有严格的“IsA”关系，这种单纯的关系<strong>有助于知识推理，但却不利于表达概念的多样性</strong>。</p></br><p>本体可以采用人工编辑的方式手动构建，即借助<strong>本体编辑软件</strong>：</p><p><img src="https://me.jinchuang.org/usr/uploads/2020/01/2122950147.png" alt="本体编辑软件-protege"></p><p>也可以用<strong>数据驱动的自动化方式</strong>构建本体，包含三个阶段：实体并列关系相似度计算、实体上下位关系抽取、本体的生成。</p><ol><li><strong>实体并列关系相似度：</strong>用于考察任意给定的 2 个实体在多大程度上属于同一概念分类的指标测度，相似度越高，表明这 2 个实体越有可能属于同一语义类别。所谓并列关系，是相对于纵向的概念隶属关系而言的。例如“中国”和“美国”作为国家名称的实体，具有较高的并列关系相似度；而“美国”和“手机”这 2 个实体，属于同一语义类别的可能性较低，因此具有较低的并列关系相似度。</li><li><strong>实体上下位关系抽取：</strong>用于确定概念之间的隶属（IsA）关系，这种关系也称为上下位关系，例如，词组（导弹，武器）构成上下位关系，其中的“导弹”为下位词，“武器”为上位词。</li><li><strong>本体生成：</strong>用于对得到的概念进行聚类，并对其进行语义类的标定，即为该类中的实体指定 1 个或多个公共上位词。</li></ol><p><strong>举例说明</strong></p><ol><li><strong>计算实体并列关系相似度：</strong>当知识图谱刚刚得到“中国”、“美国”、“手机”这三个实体（概念）时，可能会认为它们三个之间并没有什么差别。但当它去计算三个实体之间的相似度后，就会发现“中国”、“美国”之间相似度高，可能属于同一语义类别；“中国”和“手机”、“美国”和“手机”之间相似度低，可能不属于同一语义类别。</li><li><strong>抽取实体上下位关系：</strong>确定“中国”和“美国”这两个实体共同的上位概念。在这个例子中，可能的上位概念是“国家”或“主权国家”。确定上位概念后，查找表达实体上下位关系的词语。常见的上下位关系词语包括：“是一种”、“属于”、“包括”等，可能会用到类似“中国是一个国家”、“美国是一个国家”的表达方式。</li><li><strong>生成本体：</strong>在这个例子中，我们将“中国”和“美国”聚类到“国家”类别中，而“手机”则属于“科技产品”类别。然后为每个类别中的实体指定了一个或多个公共上位词。“中国”和“美国”可以共享“政治实体”作为它们的公共上位词，而“手机”可以有“智能设备”作为其公共上位词。</li></ol></br><h3 id="4-2-知识推理"><a href="#4-2-知识推理" class="headerlink" title="4.2  知识推理"></a>4.2  知识推理</h3><blockquote><p>在我们完成了本体构建这一步之后，一个知识图谱的雏形便已经搭建好了。但可能在这个时候，知识图谱之间大多数关系都是残缺的，缺失值非常严重，那么这个时候，我们就可以使用知识推理技术，去完成进一步的知识发现。</p></blockquote><p>知识推理是指从知识库中已有的实体关系数据出发，经过计算机推理，建立实体间的新关联，从而拓展和丰富知识网络。</p><p>例如，已知（乾隆，父亲，雍正）和（雍正，父亲，康熙），可以得到（乾隆，祖父，康熙）或（康熙，孙子，乾隆）。知识推理的对象并不局限于实体间的关系，也可以是实体的属性值、本体的概念层次关系等。例如，已知某实体的生日属性，可以通过推理得到该实体的年龄属性。根据本体库中的概念继承关系，也可以进行概念推理。例如，已知（老虎，科，猫科）和（猫科，目，食肉目），可以推出（老虎，目，食肉目）。</p><p>这一块的算法主要可以分为 3 大类，<strong>基于逻辑的推理、基于图的推理、基于深度学习的推理</strong>。</p></br><h3 id="4-3-质量评估"><a href="#4-3-质量评估" class="headerlink" title="4.3  质量评估"></a>4.3  质量评估</h3><p>质量评估也是知识库构建技术的重要组成部分，这一部分存在的意义在于：可以对知识的可信度进行量化，通过舍弃置信度较低的知识来保障知识库的质量。</p></br></br><h2 id="五、知识更新"><a href="#五、知识更新" class="headerlink" title="五、知识更新"></a>五、知识更新</h2><p>从逻辑上看，知识库的更新包括数据层的更新和概念层的更新。<strong>数据层的更新</strong>主要是新增或更新实体、关系和属性值，对数据层进行更新时需要考虑数据源的可靠性、数据的一致性（是否存在矛盾或冗余等问题）等多方面因素。<strong>概念层的更新</strong>是指新增数据后获得了新的概念，需要自动将新的概念添加到知识库的概念层中。</p><p>知识图谱的内容更新有两种方式：</p><ul><li>全面更新：指以更新后的全部数据为输入，从零开始构建知识图谱。这种方法比较简单，但资源消耗大，而且需要耗费大量人力资源进行系统维护；</li><li>增量更新：以当前新增数据为输入，向现有知识图谱中添加新增知识。这种方式资源消耗小，但目前仍需要大量人工干预（定义规则等），因此实施起来十分困难。</li></ul></br></br><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过知识图谱技术，不仅可以将互联网的信息表达成更接近人类认知世界的形式，而且提供了一种更好的组织、管理和利用海量信息的方式。目前的知识图谱技术主要用于<strong>智能语义搜索、移动个人助理（Siri）以及深度问答系统（Watson）</strong>，支撑这些应用的核心技术正是知识图谱技术。</p><p>在智能语义搜索中，当用户发起查询时，搜索引擎会借助知识图谱的帮助对用户查询的关键词进行解析和推理，进而将其映射到知识图谱中的一个或一组概念之上，然后根据知识图谱的概念层次结构，向用户返回图形化的知识结构，这就是我们在谷歌和百度的搜索结果中看到的<strong>知识卡片</strong>。</p><p>在深度问答应用中，系统同样会首先在知识图谱的帮助下对用户使用自然语言提出的问题进行语义分析和语法分析，进而将其转化成<strong>结构化形式的查询语句</strong>，然后在知识图谱中查询答案。比如，如果用户提问：『如何判断是否感染了埃博拉病毒？』，则该查询有可能被等价变换为『埃博拉病毒的症状有哪些？』，然后再进行推理变换，<strong>最终形成等价的三元组查询语句</strong>，如（埃博拉，症状，？）和（埃博拉，征兆，？）等。如果由于知识库不完善而无法通过推理来解答用户的问题，深度问答系统还可以利用搜索引擎向用户反馈搜索结果，同时根据搜索结果更新知识库，从而为回答后续的提问提前做出准备。</p>]]></content>
    
    
    
    <tags>
      
      <tag>知识图谱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知识图谱</title>
    <link href="/2023/11/16/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    <url>/2023/11/16/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h1><h2 id="一、知识图谱定义"><a href="#一、知识图谱定义" class="headerlink" title="一、知识图谱定义"></a>一、知识图谱定义</h2><p>中文：知识图谱</p><p>英文：Knowledge Graph</p><p>功能：以符号形式描述物理世界中的概念及其相互关系。</p><p>基本组成单位：三元组</p><ul><li>实体-关系-实体</li><li>实体-属性-属性值</li></ul><p>实体间通过关系相互联结，构成网状的知识结构。</p><p>知识图谱可以实现 Web 从网页链接向概念链接的转变，支持用户按主题而不是字符串检索，真正实现<strong>语义检索。</strong>基于知识图谱的搜索引擎，能够以图形方式向用户反馈结构化的知识，用户不必浏览大量网页即能准确定位和深度获取知识。</p></br></br><h2 id="二、语义网技术栈"><a href="#二、语义网技术栈" class="headerlink" title="二、语义网技术栈"></a>二、语义网技术栈</h2><p><img src="https://hexo-0711.oss-cn-chengdu.aliyuncs.com/image/2.png" alt="语义网技术栈"></p></br></br><h3 id="2-1-URI"><a href="#2-1-URI" class="headerlink" title="2.1  URI"></a>2.1  URI</h3><p>URI（Uniform Resource Identifier，统一资源标识符）是一种用于唯一标识和定位资源的字符序列，包括两个具体的子集：</p><ul><li>URL（Uniform Resource Locator，统一资源定位符）</li><li>URN（Uniform Resource Name，统一资源名称）</li></ul></br><h4 id="2-1-1-URL"><a href="#2-1-1-URL" class="headerlink" title="2.1.1  URL"></a>2.1.1  URL</h4><p>URL 不仅能唯一标识资源，还能定位和获取资源。</p><p>通常，URL 包括协议（如 HTTP 或 HTTPS）、主机名、路径和可选的查询参数和片段标识符。</p><p>例如，<a href="https://www.ive.com/index.html">https://www.ive.com/index.html</a> 是一个 URL。</p><table><thead><tr><th>协议</th><th>主机名</th><th>路径</th></tr></thead><tbody><tr><td>https: 或者 http:</td><td><a href="http://www.ive.com/">www.ive.com</a></td><td>index.html</td></tr></tbody></table></br><h4 id="2-1-2-标识符：URN"><a href="#2-1-2-标识符：URN" class="headerlink" title="2.1.2  标识符：URN"></a>2.1.2  标识符：URN</h4><p>URN 只能唯一标识资源，不能定位和获取资源。</p><p>设计 URN 是为了提供一种持久的标识，即使资源在不同的位置或网络状态下也能被唯一识别。</p><p>通常，URN 包括协议标识符（urn）、特定命名空间标识符和特定资源标识符（resource-id）。</p><p>例如，urn:isbn:0451450523 是一个 URN，用于标识一本书的 ISBN 号。</p><table><thead><tr><th>协议标识符</th><th>特定命名空间标识符</th><th>特定资源标识符</th></tr></thead><tbody><tr><td>urn</td><td>isbn</td><td>0451450523</td></tr></tbody></table></br><h4 id="2-1-3-URL-和-URN"><a href="#2-1-3-URL-和-URN" class="headerlink" title="2.1.3  URL 和 URN"></a>2.1.3  URL 和 URN</h4><blockquote><p>Q：既然 URL 都这么强了，为什么还要 URN？</p></blockquote><p>URN 弥补了 URL 在资源标识方面的局限性：</p><ol><li>持久性标识：URN 提供的资源标识是持久的，即使资源的位置或访问方式发生变化也不会影响其标识。这意味着即使资源的 URL 发生变化，使用 URN 标识的资源仍然可以被准确地引用和访问。</li><li>解耦资源与位置：URN 将资源标识和资源的位置进行解耦。URN 仅关注资源的标识和身份，而不依赖于资源的特定位置或获取方式。这对于需要在多个场景中共享和引用资源，而不受资源位置的限制的情况（访问受限、位置变化、失效链接、内容更改）特别有用。</li><li>语义化的标识：URN 可以使用具有语义意义的命名空间和标识符来描述资源，使得资源标识更加易读、易理解和易于管理。URN 的语义化标识有助于提高资源的可发现性和语义互操作性。</li><li>多个 URL 的映射：一个资源可能具有多个 URL，用于不同的访问方式、不同的协议或不同的位置。使用 URN 可以将这些多个 URL 映射到一个统一的标识，使得在引用资源时更加方便和一致。</li></ol></br></br><h3 id="2-2-语法：XML"><a href="#2-2-语法：XML" class="headerlink" title="2.2  语法：XML"></a>2.2  语法：XML</h3><p>菜鸟教程：<a href="https://www.runoob.com/xml/xml-tutorial.html">https://www.runoob.com/xml/xml-tutorial.html</a></p><p>XML 指可扩展标记语言（e<strong>X</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage）。</p><p><strong>XML 被设计用来传输和存储数据，</strong>不用于表现和展示数据，HTML 则用来表现数据。</p></br><h4 id="2-2-1-XML-实例"><a href="#2-2-1-XML-实例" class="headerlink" title="2.2.1  XML 实例"></a>2.2.1  XML 实例</h4><p><img src="/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.assets/3.png"></p><p>用 XML 来表示上图所示的一本书：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;COOKING&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Everyday Italian<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>Giada De Laurentiis<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2005<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>30.00<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;CHILDREN&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>J K. Rowling<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2005<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span> <span class="hljs-attr">category</span>=<span class="hljs-string">&quot;WEB&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Learning XML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>Erik T. Ray<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2003<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>39.95<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span><br></code></pre></td></tr></table></figure></br></br><h3 id="2-3-数据交换：RDF"><a href="#2-3-数据交换：RDF" class="headerlink" title="2.3  数据交换：RDF"></a>2.3  数据交换：RDF</h3><p>全称：Resource Description Framework</p><p>中文：资源描述框架</p><p>RDF 使用 Web 标识符来标识事物，并通过属性和属性值来描述资源。</p><p>对资源、属性和属性值的解释：</p><ul><li>资源是可拥有 URI 的任何事物，比如 “<a href="https://www.runoob.com/rdf">https://www.runoob.com//rdf</a>“</li><li>属性是拥有名称的资源，比如 “author” 或 “homepage”</li><li>属性值是某个属性的值，比如 “David” 或 “<a href="https://www.runoob.com/">https://www.runoob.com/</a>“</li></ul><blockquote><p>注意：一个属性值除了可以是字面值，还可以是另外一个资源。</p></blockquote></br><h4 id="2-3-1-RDF-陈述"><a href="#2-3-1-RDF-陈述" class="headerlink" title="2.3.1  RDF 陈述"></a>2.3.1  RDF 陈述</h4><p>资源、属性和属性值的组合可形成一个陈述（被称为陈述的主体、谓语和客体）。</p><p>请看一些陈述的具体例子，来加深理解：</p><p>陈述：”The author of <a href="https://www.runoob.com/rdf">https://www.runoob.com//rdf</a> is David.”</p><ul><li>陈述的主体是：<a href="https://www.runoob.com//rdf">https://www.runoob.com//rdf</a></li><li>谓语是：author</li><li>客体是：David</li></ul><p>陈述：”The homepage of <a href="https://www.runoob.com/rdf">https://www.runoob.com//rdf</a> is <a href="https://www.runoob.com/">https://www.runoob.com/</a>“.</p><ul><li>陈述的主体是：<a href="https://www.runoob.com//rdf">https://www.runoob.com//rdf</a></li><li>谓语是：homepage</li><li>客体是：<a href="https://www.runoob.com/">https://www.runoob.com/</a></li></ul></br><h4 id="2-3-2-RDF-实例"><a href="#2-3-2-RDF-实例" class="headerlink" title="2.3.2  RDF 实例"></a>2.3.2  RDF 实例</h4><p>这是一个 CD 列表的其中几行：</p><table><thead><tr><th><strong>标题</strong></th><th><strong>艺术家</strong></th><th><strong>国家</strong></th><th><strong>公司</strong></th><th><strong>价格</strong></th><th><strong>年份</strong></th></tr></thead><tbody><tr><td>Empire Burlesque</td><td>Bob Dylan</td><td>USA</td><td>Columbia</td><td>10.90</td><td>1985</td></tr><tr><td>Hide your heart</td><td>Bonnie Tyler</td><td>UK</td><td>CBS Records</td><td>9.90</td><td>1988</td></tr></tbody></table><p>这是一个 RDF 文档的其中几行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">rdf:RDF</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:rdf</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:cd</span>=<span class="hljs-string">&quot;http://www.recshop.fake/cd#&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">rdf:Description</span></span><br><span class="hljs-tag"><span class="hljs-attr">rdf:about</span>=<span class="hljs-string">&quot;http://www.recshop.fake/cd/Empire Burlesque&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cd:artist</span>&gt;</span>Bob Dylan<span class="hljs-tag">&lt;/<span class="hljs-name">cd:artist</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cd:country</span>&gt;</span>USA<span class="hljs-tag">&lt;/<span class="hljs-name">cd:country</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cd:company</span>&gt;</span>Columbia<span class="hljs-tag">&lt;/<span class="hljs-name">cd:company</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cd:price</span>&gt;</span>10.90<span class="hljs-tag">&lt;/<span class="hljs-name">cd:price</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cd:year</span>&gt;</span>1985<span class="hljs-tag">&lt;/<span class="hljs-name">cd:year</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">rdf:Description</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">rdf:Description</span></span><br><span class="hljs-tag"><span class="hljs-attr">rdf:about</span>=<span class="hljs-string">&quot;http://www.recshop.fake/cd/Hide your heart&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cd:artist</span>&gt;</span>Bonnie Tyler<span class="hljs-tag">&lt;/<span class="hljs-name">cd:artist</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cd:country</span>&gt;</span>UK<span class="hljs-tag">&lt;/<span class="hljs-name">cd:country</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cd:company</span>&gt;</span>CBS Records<span class="hljs-tag">&lt;/<span class="hljs-name">cd:company</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cd:price</span>&gt;</span>9.90<span class="hljs-tag">&lt;/<span class="hljs-name">cd:price</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cd:year</span>&gt;</span>1988<span class="hljs-tag">&lt;/<span class="hljs-name">cd:year</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">rdf:Description</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">rdf:RDF</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>此 RDF 文档的第一行是 XML 声明。这个 XML 声明之后是 RDF 文档的根元素：*<a href="rdf:RDF">rdf:RDF</a>*。</p><p><em>xmlns:rdf</em> 命名空间，规定了带有前缀 rdf 的元素来自命名空间 “<a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#%22%E3%80%82">http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;。</a></p><p><em>xmlns:cd</em> 命名空间，规定了带有前缀 cd 的元素来自命名空间 “<a href="http://www.recshop.fake/cd#%22%E3%80%82">http://www.recshop.fake/cd#&quot;。</a></p><p><em><a href="rdf:Description">rdf:Description</a></em> 元素包含了对被 <em>rdf:about</em> 属性标识的资源的描述。</p><p>元素：*<a href="cd:artist">cd:artist</a><em>、</em><a href="cd:country">cd:country</a>*、</p><p><a href="cd:company">cd:company</a> 等是此资源的属性。</p><ul><li>陈述的主体是：<a href="http://www.recshop.fake/cd/Empire">http://www.recshop.fake/cd/Empire</a> Burlesque</li><li>谓语是：cd:artist、cd:country、cd:company、cd:price、cd:year</li><li>客体是：Bob Dylan、USA、Columbia、10.90、1985</li></ul></br></br><h3 id="2-4-分类法：RDF-S"><a href="#2-4-分类法：RDF-S" class="headerlink" title="2.4  分类法：RDF-S"></a>2.4  分类法：RDF-S</h3><p>RDF 的表达能力有限，无法区分类和对象，也无法定义和描述类的关系。RDF 是对具体事物的描述，缺乏抽象能力，无法对同一类别的事物进行定义和描述，需要 Schema 的引入。RDFS，即“Resource Description Framework Schema”模式语言作为 RDF 的补充解决了 RDF 表达能力有限的困境。</p></br><h4 id="2-4-1-RDF-S-常用词汇"><a href="#2-4-1-RDF-S-常用词汇" class="headerlink" title="2.4.1  RDF-S 常用词汇"></a>2.4.1  RDF-S 常用词汇</h4><p>RDFS 中常用的词汇：</p><ul><li>rdfs:Class：用于定义类。</li><li>rdfs:domain：用于表示该属性属于哪个类别。</li><li>rdfs:range：用于描述该属性的取值类型。</li><li>rdfs:subClassOf：用于描述该类的父类。</li></ul><p>比如，我们可以定义一个运动员类，声明该类是人的子类。</p><ul><li>rdfs:subProperty：用于描述该属性的父属性。</li></ul><p>比如，我们可以定义一个名称属性，声明中文名称和全名是名称的子类。</p></br><h4 id="2-4-2-RDF-S-实例"><a href="#2-4-2-RDF-S-实例" class="headerlink" title="2.4.2  RDF-S 实例"></a>2.4.2  RDF-S 实例</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">rdf:RDF</span> <span class="hljs-attr">xmlns:rdf</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:rdfs</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/01/rdf-schema#&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 声明一个类（Class） --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:Class</span> <span class="hljs-attr">rdf:about</span>=<span class="hljs-string">&quot;#Person&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:label</span>&gt;</span>Person<span class="hljs-tag">&lt;/<span class="hljs-name">rdfs:label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:comment</span>&gt;</span>A class representing a person.<span class="hljs-tag">&lt;/<span class="hljs-name">rdfs:comment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rdfs:Class</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 声明一个属性（Property） --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rdf:Property</span> <span class="hljs-attr">rdf:about</span>=<span class="hljs-string">&quot;#hasName&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:label</span>&gt;</span>hasName<span class="hljs-tag">&lt;/<span class="hljs-name">rdfs:label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:comment</span>&gt;</span>Relates a person to their name.<span class="hljs-tag">&lt;/<span class="hljs-name">rdfs:comment</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:domain</span> <span class="hljs-attr">rdf:resource</span>=<span class="hljs-string">&quot;#Person&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:range</span> <span class="hljs-attr">rdf:resource</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema#string&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rdf:Property</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 创建一个实例（Instance） --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rdf:Description</span> <span class="hljs-attr">rdf:about</span>=<span class="hljs-string">&quot;#John&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rdf:type</span> <span class="hljs-attr">rdf:resource</span>=<span class="hljs-string">&quot;#Person&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hasName</span>&gt;</span>John Doe<span class="hljs-tag">&lt;/<span class="hljs-name">hasName</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rdf:Description</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 定义子类关系（Subclass） --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:Class</span> <span class="hljs-attr">rdf:about</span>=<span class="hljs-string">&quot;#Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:label</span>&gt;</span>Student<span class="hljs-tag">&lt;/<span class="hljs-name">rdfs:label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:comment</span>&gt;</span>A subclass representing a student.<span class="hljs-tag">&lt;/<span class="hljs-name">rdfs:comment</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:subClassOf</span> <span class="hljs-attr">rdf:resource</span>=<span class="hljs-string">&quot;#Person&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rdfs:Class</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 定义属性子属性（Subproperty） --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">rdf:Property</span> <span class="hljs-attr">rdf:about</span>=<span class="hljs-string">&quot;#hasEmail&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:subPropertyOf</span> <span class="hljs-attr">rdf:resource</span>=<span class="hljs-string">&quot;#hasName&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rdfs:comment</span>&gt;</span>Relates a person to their email address.<span class="hljs-tag">&lt;/<span class="hljs-name">rdfs:comment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">rdf:Property</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">rdf:RDF</span>&gt;</span><br></code></pre></td></tr></table></figure></br></br><h3 id="2-5-本体：OWL"><a href="#2-5-本体：OWL" class="headerlink" title="2.5  本体：OWL"></a>2.5  本体：OWL</h3><p>OWL的本体在RDFS具有的类、属性、实例的基础上，加入了关系、限制和公理。</p><p>通过 RDF(S) 可以表达一些简单的语义，但在更复杂的场景下，RDF(S)语义表达能力显得太弱，还缺少诸多常用的特征。包括对局部值域的属性定义，类、属性、个体的等价性，不相交类的定义，基数约束，关于属性特征的描述等。因此W3C提出了OWL语言扩展RDF(S)，作为语义网上表示本体的推荐语言。OWL可以看作是RDFS的一个扩展，添加了额外的预定义词汇。</p><p>OWL相较于RDFS，引入了布尔算子（并、或、补）、递归地构建复杂的类，还提供了表示存在值约束、任意值约束和数量值约束等能力。同时，OWL能提供描述属性具有传递性、对称性、函数性等性质。还有两个类等价或者不相交，两个属性等价或者互逆，两个实例相同或者不同，还有枚举类等等。</p><p>OWL 描述属性常用的词汇：</p><p>描述属性特征的词汇</p><ul><li>owl:TransitiveProperty.表示该属性具有传递性质。例如，我们定义“位于”是具有传递性的属性，若A位于B，B位于C，那么A肯定位于C。</li><li>owl:SymmetricProperty.     表示该属性具有对称性。例如，我们定义“认识”是具有对称性的属性，若A认识B，那么B肯定认识A。</li><li>owl:FunctionalProperty.     表示该属性取值的唯一性。 例如，我们定义“母亲”是具有唯一性的属性，若A的母亲是B，在其他地方我们得知A的母亲是C，那么B和C指的是同一个人。</li><li>owl:inverseOf.     定义某个属性的相反关系。例如，定义“父母”的相反关系是“子女”，若A是B的父母，那么B肯定是A的子女。</li></ul><p>本体映射词汇（Ontology Mapping）</p><ul><li>owl:equivalentClass.     表示某个类和另一个类是相同的。</li><li>owl:equivalentProperty.     表示某个属性和另一个属性是相同的。</li><li>owl:sameAs. 表示两个实体是同一个实体。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>知识图谱</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
